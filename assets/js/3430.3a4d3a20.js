"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[3430],{63430:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>r,toc:()=>p});var i=t(87462),a=(t(67294),t(3905));t(45475);const o={title:"Unions",slug:"/types/unions"},s=void 0,r={unversionedId:"types/unions",id:"types/unions",title:"Unions",description:"Sometimes it's useful to create a type which is one of a set of other",source:"@site/docs/types/unions.md",sourceDirName:"types",slug:"/types/unions",permalink:"/en/docs/types/unions",draft:!1,editUrl:"https://github.com/facebook/flow/edit/main/website/docs/types/unions.md",tags:[],version:"current",frontMatter:{title:"Unions",slug:"/types/unions"},sidebar:"docsSidebar",previous:{title:"Generics",permalink:"/en/docs/types/generics"},next:{title:"Intersections",permalink:"/en/docs/types/intersections"}},l={},p=[{value:"Union type syntax",id:"toc-union-type-syntax",level:2},{value:"Union shorthands",id:"union-shorthands",level:2},{value:"Unions &amp; Refinements",id:"toc-unions-refinements",level:2},{value:"Union types requires one in, but all out",id:"toc-union-types-requires-one-in-but-all-out",level:2},{value:"Disjoint Object Unions",id:"toc-disjoint-object-unions",level:2},{value:"Disjoint object unions with exact types",id:"toc-disjoint-unions-with-exact-types",level:3}],u={toc:p};function m(e){let{components:n,...t}=e;return(0,a.mdx)("wrapper",(0,i.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.mdx)("p",null,"Sometimes it's useful to create a type which is ",(0,a.mdx)("strong",{parentName:"p"},(0,a.mdx)("em",{parentName:"strong"},"one of"))," a set of other\ntypes. For example, you might want to write a function which accepts a set of\nprimitive value types. For this Flow supports ",(0,a.mdx)("strong",{parentName:"p"},"union types"),"."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":9,"startColumn":20,"endLine":9,"endColumn":32,"description":"Cannot call `toStringPrimitives` with object literal bound to `value` because: [incompatible-call] Either object literal [1] is incompatible with number [2]. Or object literal [1] is incompatible with boolean [3]. Or object literal [1] is incompatible with string [4]."},{"startLine":10,"startColumn":20,"endLine":10,"endColumn":34,"description":"Cannot call `toStringPrimitives` with array literal bound to `value` because: [incompatible-call] Either array literal [1] is incompatible with number [2]. Or array literal [1] is incompatible with boolean [3]. Or array literal [1] is incompatible with string [4]."}]','[{"startLine":9,"startColumn":20,"endLine":9,"endColumn":32,"description":"Cannot':!0,call:!0,"`toStringPrimitives`":!0,with:!0,object:!0,literal:!0,bound:!0,to:!0,"`value`":!0,"because:":!0,"[incompatible-call]":!0,Either:!0,"[1]":!0,is:!0,incompatible:!0,number:!0,"[2].":!0,Or:!0,boolean:!0,"[3].":!0,string:!0,'[4]."},{"startLine":10,"startColumn":20,"endLine":10,"endColumn":34,"description":"Cannot':!0,array:!0,'[4]."}]':!0},"function toStringPrimitives(value: number | boolean | string): string {\n  return String(value);\n}\n\ntoStringPrimitives(1);       // Works!\ntoStringPrimitives(true);    // Works!\ntoStringPrimitives('three'); // Works!\n\ntoStringPrimitives({prop: 'val'}); // Error!\ntoStringPrimitives([1, 2, 3, 4, 5]); // Error!\n")),(0,a.mdx)("h2",{id:"toc-union-type-syntax"},"Union type syntax"),(0,a.mdx)("p",null,"Union types are any number of types which are joined by a vertical bar ",(0,a.mdx)("inlineCode",{parentName:"p"},"|"),"."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"Type1 | Type2 | ... | TypeN\n")),(0,a.mdx)("p",null,"You may also add a leading vertical bar which is useful when breaking union\ntypes onto multiple lines."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"type Foo =\n  | Type1\n  | Type2\n  | ...\n  | TypeN\n")),(0,a.mdx)("p",null,"Each of the members of a union type can be any type, even another union type."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type Numbers = 1 | 2;\ntype Colors = 'red' | 'blue'\n\ntype Fish = Numbers | Colors;\n")),(0,a.mdx)("p",null,"If you have enabled ",(0,a.mdx)("a",{parentName:"p",href:"../../enums/"},"Flow Enums"),", they may be an alternative to unions of ",(0,a.mdx)("a",{parentName:"p",href:"../literals"},"literal types"),"."),(0,a.mdx)("h2",{id:"union-shorthands"},"Union shorthands"),(0,a.mdx)("p",null,"The union of some type ",(0,a.mdx)("inlineCode",{parentName:"p"},"T")," with ",(0,a.mdx)("inlineCode",{parentName:"p"},"null")," or ",(0,a.mdx)("inlineCode",{parentName:"p"},"void")," is common, so we provide a shorthand called ",(0,a.mdx)("a",{parentName:"p",href:"../maybe"},"maybe types"),", by using the ",(0,a.mdx)("inlineCode",{parentName:"p"},"?")," prefix. The type ",(0,a.mdx)("inlineCode",{parentName:"p"},"?T")," is equivalent to ",(0,a.mdx)("inlineCode",{parentName:"p"},"T | null | void"),":"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function maybeString(x: ?string) { /* ... */ }\nmaybeString('hi'); // Works!\nmaybeString(null); // Works!\nmaybeString(undefined); // Works!\n")),(0,a.mdx)("p",null,"The union of every single type that exists is the ",(0,a.mdx)("a",{parentName:"p",href:"../mixed"},(0,a.mdx)("inlineCode",{parentName:"a"},"mixed"))," type:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function everything(x: mixed) { /* ... */ }\neverything(1); // Works!\neverything(true); // Works!\neverything(null); // Works!\neverything({foo: 1}); // Works!\neverything(new Error()); // Works!\n")),(0,a.mdx)("h2",{id:"toc-unions-refinements"},"Unions & Refinements"),(0,a.mdx)("p",null,"When you have a value which is a union type it's often useful to break it apart\nand handle each individual type separately. With union types in Flow you can\n",(0,a.mdx)("a",{parentName:"p",href:"../../lang/refinements"},"refine")," the value down to a single type."),(0,a.mdx)("p",null,"For example, if we have a value with a union type that is a ",(0,a.mdx)("inlineCode",{parentName:"p"},"number"),", a\n",(0,a.mdx)("inlineCode",{parentName:"p"},"boolean"),", or a ",(0,a.mdx)("inlineCode",{parentName:"p"},"string"),", we can treat the number case separately by using\nJavaScript's ",(0,a.mdx)("inlineCode",{parentName:"p"},"typeof")," operator."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function toStringPrimitives(value: number | boolean | string) {\n  if (typeof value === 'number') {\n    return value.toLocaleString([], {maximumSignificantDigits: 3}); // Works!\n  }\n  // ...\n}\n")),(0,a.mdx)("p",null,"By checking the ",(0,a.mdx)("inlineCode",{parentName:"p"},"typeof")," our value and testing to see if it is a ",(0,a.mdx)("inlineCode",{parentName:"p"},"number"),", Flow\nknows that inside of that block it is only a number. We can then write code\nwhich treats our value as a number inside of that block."),(0,a.mdx)("h2",{id:"toc-union-types-requires-one-in-but-all-out"},"Union types requires one in, but all out"),(0,a.mdx)("p",null,"When calling a function that accepts a union type we must pass in ",(0,a.mdx)("strong",{parentName:"p"},(0,a.mdx)("em",{parentName:"strong"},"one of\nthose types")),". But inside of the function we are required to handle ",(0,a.mdx)("strong",{parentName:"p"},(0,a.mdx)("em",{parentName:"strong"},"all of\nthe possible types")),"."),(0,a.mdx)("p",null,"Let's rewrite the function to handle each type individually using ",(0,a.mdx)("a",{parentName:"p",href:"../../lang/refinements"},"refinements"),"."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"function toStringPrimitives(value: number | boolean | string): string {\n  if (typeof value === 'number') {\n    return String(value);\n  } else if (typeof value === 'boolean') {\n    return String(value);\n  }\n  return value; // If we got here, it's a `string`!\n}\n")),(0,a.mdx)("p",null,"If we do not handle each possible type of our value, Flow will give us an error:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":5,"startColumn":10,"endLine":5,"endColumn":14,"description":"Cannot return `value` because boolean [1] is incompatible with string [2]. [incompatible-return]"}]','[{"startLine":5,"startColumn":10,"endLine":5,"endColumn":14,"description":"Cannot':!0,return:!0,"`value`":!0,because:!0,boolean:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,string:!0,"[2].":!0,'[incompatible-return]"}]':!0},"function toStringPrimitives(value: number | boolean | string): string {\n  if (typeof value === 'number') {\n    return String(value);\n  }\n  return value; // Error!\n}\n")),(0,a.mdx)("h2",{id:"toc-disjoint-object-unions"},"Disjoint Object Unions"),(0,a.mdx)("p",null,'There\'s a special type of union in Flow known as a "disjoint object union" which can\nbe used with ',(0,a.mdx)("a",{parentName:"p",href:"../../lang/refinements/"},"refinements"),". These disjoint object unions are\nmade up of any number of object types which are each tagged by a single property."),(0,a.mdx)("p",null,"For example, imagine we have a function for handling a response from a server\nafter we've sent it a request. When the request is successful, we'll get back\nan object with a ",(0,a.mdx)("inlineCode",{parentName:"p"},"type")," property set to ",(0,a.mdx)("inlineCode",{parentName:"p"},"'success'")," and a ",(0,a.mdx)("inlineCode",{parentName:"p"},"value")," that we've\nupdated."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"{type: 'success', value: 23}\n")),(0,a.mdx)("p",null,"When the request fails, we'll get back an object with ",(0,a.mdx)("inlineCode",{parentName:"p"},"type")," set to ",(0,a.mdx)("inlineCode",{parentName:"p"},"'error'"),"\nand an ",(0,a.mdx)("inlineCode",{parentName:"p"},"error")," property describing the error."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"{type: 'error', error: 'Bad request'}\n")),(0,a.mdx)("p",null,"We can try to express both of these objects in a single object type. However,\nwe'll quickly run into issues where we know a property exists based on the\n",(0,a.mdx)("inlineCode",{parentName:"p"},"type")," property but Flow does not."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":9,"startColumn":27,"endLine":9,"endColumn":40,"description":"Cannot assign `response.value` to `value` because undefined [1] is incompatible with number [2]. [incompatible-type]"},{"startLine":11,"startColumn":27,"endLine":11,"endColumn":40,"description":"Cannot assign `response.error` to `error` because undefined [1] is incompatible with string [2]. [incompatible-type]"}]','[{"startLine":9,"startColumn":27,"endLine":9,"endColumn":40,"description":"Cannot':!0,assign:!0,"`response.value`":!0,to:!0,"`value`":!0,because:!0,undefined:!0,"[1]":!0,is:!0,incompatible:!0,with:!0,number:!0,"[2].":!0,'[incompatible-type]"},{"startLine":11,"startColumn":27,"endLine":11,"endColumn":40,"description":"Cannot':!0,"`response.error`":!0,"`error`":!0,string:!0,'[incompatible-type]"}]':!0},"type Response = {\n  type: 'success' | 'error',\n  value?: number,\n  error?: string\n};\n\nfunction handleResponse(response: Response) {\n  if (response.type === 'success') {\n    const value: number = response.value; // Error!\n  } else {\n    const error: string = response.error; // Error!\n  }\n}\n")),(0,a.mdx)("p",null,"Trying to combine these two separate types into a single one will only cause us\ntrouble."),(0,a.mdx)("p",null,"Instead, if we create a union type of both object types, Flow will be able to\nknow which object we're using based on the ",(0,a.mdx)("inlineCode",{parentName:"p"},"type")," property."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type Response =\n  | {type: 'success', value: 23}\n  | {type: 'error', error: string};\n\nfunction handleResponse(response: Response) {\n  if (response.type === 'success') {\n    const value: number = response.value; // Works!\n  } else {\n    const error: string = response.error; // Works!\n  }\n}\n")),(0,a.mdx)("p",null,"In order to use this pattern, there must be a key that is in every object in your union (in our example above, ",(0,a.mdx)("inlineCode",{parentName:"p"},"type"),"),\nand every object must set a different ",(0,a.mdx)("a",{parentName:"p",href:"../literals"},"literal type")," for that key (in our example, the string ",(0,a.mdx)("inlineCode",{parentName:"p"},"'success'"),", and the string ",(0,a.mdx)("inlineCode",{parentName:"p"},"'error'"),").\nYou can use any kind of literal type, including numbers and booleans."),(0,a.mdx)("h3",{id:"toc-disjoint-unions-with-exact-types"},"Disjoint object unions with exact types"),(0,a.mdx)("p",null,"Disjoint unions require you to use a single property to distinguish each object\ntype. You cannot distinguish two different ",(0,a.mdx)("a",{parentName:"p",href:"../objects/#exact-and-inexact-object-types"},"inexact objects")," by different properties."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:'[{"startLine":6,"startColumn":37,"endLine":6,"endColumn":41,"description":"Cannot get `response.value` because property `value` is missing in object type [1]. [prop-missing]"}]','[{"startLine":6,"startColumn":37,"endLine":6,"endColumn":41,"description":"Cannot':!0,get:!0,"`response.value`":!0,because:!0,property:!0,"`value`":!0,is:!0,missing:!0,in:!0,object:!0,type:!0,"[1].":!0,'[prop-missing]"}]':!0},"type Success = {success: true, value: boolean, ...};\ntype Failed  = {error: true, message: string, ...};\n\nfunction handleResponse(response:  Success | Failed) {\n  if (response.success) {\n    const value: boolean = response.value; // Error!\n  }\n}\n")),(0,a.mdx)("p",null,"This is because in Flow it is okay to pass an object value with more properties\nthan the inexact object type expects (because of ",(0,a.mdx)("a",{parentName:"p",href:"../../lang/width-subtyping/"},"width subtyping"),")."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type Success = {success: true, value: boolean, ...};\ntype Failed  = {error: true, message: string, ...};\n\nfunction handleResponse(response:  Success | Failed) {\n  // ...\n}\n\nhandleResponse({\n  success: true,\n  error: true,\n  value: true,\n  message: 'hi'\n});\n")),(0,a.mdx)("p",null,"Unless the objects somehow conflict with one another there is no way to\ndistinguish them."),(0,a.mdx)("p",null,"However, to get around this you could use ",(0,a.mdx)("strong",{parentName:"p"},"exact object types"),"."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-flow",metastring:"[]","[]":!0},"type Success = {success: true, value: boolean};\ntype Failed  = {error: true, message: string};\n\ntype Response = Success | Failed;\n\nfunction handleResponse(response: Response) {\n  if (response.success) {\n    const value: boolean = response.value;\n  } else {\n    const message: string = response.message;\n  }\n}\n")),(0,a.mdx)("p",null,"With exact object types, we cannot have additional properties, so the objects\nconflict with one another and we are able to distinguish which is which."))}m.isMDXComponent=!0}}]);